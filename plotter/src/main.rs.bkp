use chrono::{DateTime, Local, NaiveDate, NaiveTime, TimeZone};
use regex::Regex;
use reqwest;
use serde::{Deserialize, Serialize};
use std::fs::{self, File};
use std::io::{self, BufRead, Read};
use std::path::Path;
use tokio::runtime::Runtime;

#[derive(Debug, Deserialize)]
struct HistoryEntry {
    file_name: String,
    start_datetime: DateTime<Local>,
    end_datetime: DateTime<Local>,
    data_str_formatted: String,
    inicio_str: String,
    fim_str: String,
}

#[derive(Debug)]
struct PlotAnalysis {
    width: f64,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct PlotterData {
    id: Option<i32>,
    r: f64,
    sim: f64,
    nao: f64,
    desperdicio: f64,
    data: String,
    inicio: String,
    fim: String,
    nome: String,
    plotter_nome: String,
    largura: Option<f64>,
}

#[derive(Deserialize, Debug)]
struct ApiResponse {
    rows: Vec<PlotterData>,
}

async fn create_plotter_c(
    api_url: &str,
    data: &PlotterData,
) -> Result<(), reqwest::Error> {
    let client = reqwest::Client::new();
    client
        .post(api_url)
        .json(data)
        .send()
        .await?
        .error_for_status()?;
    Ok(())
}

async fn update_plotter_c(
    api_url: &str,
    data: &PlotterData,
) -> Result<(), reqwest::Error> {
    let client = reqwest::Client::new();
    client
        .put(api_url)
        .json(data)
        .send()
        .await?
        .error_for_status()?;
    Ok(())
}

fn analyze_plt_file(path: &Path) -> io::Result<PlotAnalysis> {
    let mut file = File::open(path)?;
    let mut content = String::new();
    file.read_to_string(&mut content)?;

    let mut min_x = f64::MAX;
    let mut max_x = f64::MIN;
    let mut min_y = f64::MAX;
    let mut max_y = f64::MIN;

    let re_cmd = Regex::new(r"([A-Z]{2})([^A-Z]*)").unwrap();
    let re_coords = Regex::new(r"-?\d+\.?\d*").unwrap();

    for cap in re_cmd.captures_iter(&content) {
        let cmd = &cap[1];
        let params = &cap[2];

        let coords: Vec<f64> = re_coords
            .find_iter(params)
            .filter_map(|m| m.as_str().parse().ok())
            .collect();

        if coords.is_empty() {
            continue;
        }

        match cmd {
            "PU" | "PD" => {
                for chunk in coords.chunks(2) {
                    if let [x, y] = *chunk {
                        min_x = min_x.min(x);
                        max_x = max_x.max(x);
                        min_y = min_y.min(y);
                        max_y = max_y.max(y);
                    }
                }
            }
            _ => (),
        }
    }

    let width = if min_x == f64::MAX { 0.0 } else { max_x - min_x };

    Ok(PlotAnalysis { width })
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let rt = Runtime::new()?;
    let api_url = "http://localhost:3000/api/v1/tables/c/plotter?r=1";

    // 1. Buscar todos os registros existentes da API
    let mut existing_plotter_data: Vec<PlotterData> = rt.block_on(async {
        let response = reqwest::get(api_url).await?.json::<ApiResponse>().await?;
        Ok::<_, reqwest::Error>(response.rows)
    })?;

    let mut history_entries: Vec<HistoryEntry> = Vec::new();
    let path = Path::new("history.ini");

    if let Ok(file) = File::open(path) {
        let reader = io::BufReader::new(file);
        println!("Lendo arquivo history.ini e processando registros...");

        for (_index, line) in reader.lines().enumerate() {
            if let Ok(line_content) = line {
                if line_content.trim().is_empty() {
                    continue;
                }
                let parts: Vec<&str> = line_content.split('|').collect();

                if parts.len() >= 4 {
                    let file_path_str = parts[0];
                    let file_name = file_path_str.split('\\').last().unwrap_or("").to_string();

                    let datetime_parts: Vec<&str> = parts[1].split(' ').collect();
                    let data_original = if !datetime_parts.is_empty() { datetime_parts[0] } else { "" };
                    let inicio_str = if datetime_parts.len() >= 2 { datetime_parts[1] } else { "" };
                    let fim_str = parts[2];

                    let data_formatada = NaiveDate::parse_from_str(data_original, "%Y-%m-%d")
                        .map(|d| d.format("%d/%m/%Y").to_string())
                        .unwrap_or_else(|_| data_original.to_string());

                    let record_exists = existing_plotter_data.iter().any(|record| {
                        record.nome == file_name
                            && record.data == data_formatada
                            && record.inicio == inicio_str
                            && record.fim == fim_str
                    });

                    if !record_exists {
                        let progress_str = parts[3].trim().trim_end_matches('%');
                        let progress_val: f64 = progress_str.parse().unwrap_or(0.0);
                        let (sim, nao) = if (progress_val - 100.0).abs() < f64::EPSILON {
                            (progress_val, 0.0)
                        } else {
                            (0.0, progress_val)
                        };

                        let new_plotter_data = PlotterData {
                            id: None,
                            r: 1.0,
                            sim,
                            nao,
                            desperdicio: 0.0,
                            data: data_formatada.clone(),
                            inicio: inicio_str.to_string(),
                            fim: fim_str.to_string(),
                            nome: file_name.clone(),
                            plotter_nome: "P01".to_string(),
                            largura: None,
                        };

                        rt.block_on(async {
                            if let Err(e) = create_plotter_c(api_url, &new_plotter_data).await {
                                eprintln!("Erro ao criar novo registro via API para '{}': {}", file_name, e);
                            } else {
                                println!("Novo registro para '{}' enviado para a API com sucesso.", file_name);
                            }
                        });

                        // Atualiza a lista de dados para incluir o novo registro
                        println!("Atualizando lista de dados da API...");
                        let result: Result<Vec<PlotterData>, reqwest::Error> = rt.block_on(async {
                            let response = reqwest::get(api_url).await?;
                            let api_response = response.json::<ApiResponse>().await?;
                            Ok(api_response.rows)
                        });

                        match result {
                            Ok(new_data) => existing_plotter_data = new_data,
                            Err(e) => {
                                eprintln!("Erro ao atualizar a lista de dados da API: {}", e);
                                return Err(Box::new(e));
                            }
                        }
                    }

                    if let (Ok(date), Ok(start_time), Ok(end_time)) = (
                        NaiveDate::parse_from_str(data_original, "%Y-%m-%d"),
                        NaiveTime::parse_from_str(inicio_str, "%H:%M:%S"),
                        NaiveTime::parse_from_str(fim_str, "%H:%M:%S"),
                    ) {
                        let start_datetime = Local.from_local_datetime(&date.and_time(start_time)).unwrap();
                        let end_datetime = Local.from_local_datetime(&date.and_time(end_time)).unwrap();
                        history_entries.push(HistoryEntry {
                            file_name,
                            start_datetime,
                            end_datetime,
                            data_str_formatted: data_formatada,
                            inicio_str: inicio_str.to_string(),
                            fim_str: fim_str.to_string(),
                        });
                    }
                }
            }
        }
    } else {
        eprintln!("Erro: Não foi possível encontrar ou ler o arquivo 'history.ini'.");
    }

    let paths = fs::read_dir("./").unwrap();
    let conversion_factor = 400.0;

    for path in paths {
        let path = path.unwrap().path();
        if let Some(extension) = path.extension() {
            if extension == "plt" {
                let plt_file_name = path.file_name().unwrap().to_str().unwrap().to_string();
                println!("\nProcessando arquivo {:?}...", plt_file_name);

                let created_datetime: DateTime<Local> = if let Ok(metadata) = fs::metadata(&path) {
                    metadata.created().unwrap().into()
                } else {
                    continue;
                };
                println!("  Data de Criação: {}", created_datetime.format("%d/%m/%Y %H:%M:%S"));

                match analyze_plt_file(&path) {
                    Ok(analysis) => {
                        let width_cm = analysis.width / conversion_factor;
                        println!("  Largura: {:.2} cm", width_cm);

                        let matching_history_entry = history_entries.iter().find(|entry| {
                            entry.file_name == plt_file_name
                                && created_datetime >= entry.start_datetime
                                && created_datetime <= entry.end_datetime
                        });

                        if let Some(history_entry) = matching_history_entry {
                            if let Some(record_to_update) = existing_plotter_data.iter().find(|record| {
                                record.nome == history_entry.file_name
                                    && record.data == history_entry.data_str_formatted
                                    && record.inicio == history_entry.inicio_str
                                    && record.fim == history_entry.fim_str
                            }) {
                                let mut updated_record = record_to_update.clone();
                                updated_record.largura = Some(width_cm);

                                rt.block_on(async {
                                    if let Err(e) = update_plotter_c(api_url, &updated_record).await {
                                        eprintln!("Erro ao atualizar largura via API para '{}': {}", plt_file_name, e);
                                    } else {
                                        println!("Largura para '{}' atualizada via API com sucesso.", plt_file_name);
                                    }
                                });
                            }
                        } else {
                            println!("  -> Nenhuma correspondência de tempo encontrada em history.ini para '{}'.", plt_file_name);
                        }
                    }
                    Err(e) => eprintln!("Erro ao processar o arquivo {:?}: {}", path, e),
                }
            }
        }
    }

    Ok(())
}